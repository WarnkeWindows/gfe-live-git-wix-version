/**
 * Data Validation Functions and Collection Utilities
 * Good Faith Exteriors Iframe System
 * 
 * Phase 3: Data validation functions and collection mapping utilities
 * âœ… Complete - Ready for Phase 4 Claude AI Integration
 */

import {
    VALIDATION_SCHEMAS,
    FIELD_MAPPINGS,
    PRICING_CONFIG,
    ERRORS,
    SUCCESS,
    COLLECTIONS
} from './unified-constants.js';

// =====================================================================
// CORE VALIDATION FUNCTIONS
// =====================================================================

/**
 * Validates a string field with length constraints
 */
export function validateString(value, fieldName, minLength = 1, maxLength = 255) {
    if (typeof value !== 'string') {
        throw new Error(`${fieldName} must be a string`);
    }
    
    const trimmed = value.trim();
    
    if (trimmed.length < minLength) {
        throw new Error(`${fieldName} must be at least ${minLength} characters`);
    }
    
    if (trimmed.length > maxLength) {
        throw new Error(`${fieldName} must be no more than ${maxLength} characters`);
    }
    
    return trimmed;
}

/**
 * Validates a numeric field with range constraints
 */
export function validateNumber(value, fieldName, minValue = null, maxValue = null) {
    const num = typeof value === 'string' ? parseFloat(value) : Number(value);
    
    if (isNaN(num) || !isFinite(num)) {
        throw new Error(`${fieldName} must be a valid number`);
    }
    
    if (minValue !== null && num < minValue) {
        throw new Error(`${fieldName} must be at least ${minValue}`);
    }
    
    if (maxValue !== null && num > maxValue) {
        throw new Error(`${fieldName} must be no more than ${maxValue}`);
    }
    
    return num;
}

/**
 * Validates a boolean field
 */
export function validateBoolean(value, fieldName) {
    if (typeof value === 'boolean') {
        return value;
    }
    
    if (typeof value === 'string') {
        const lower = value.toLowerCase().trim();
        if (lower === 'true' || lower === '1' || lower === 'yes') return true;
        if (lower === 'false' || lower === '0' || lower === 'no') return false;
    }
    
    throw new Error(`${fieldName} must be a boolean value`);
}

/**
 * Validates an array field
 */
export function validateArray(value, fieldName, minLength = 0, maxLength = null) {
    if (!Array.isArray(value)) {
        throw new Error(`${fieldName} must be an array`);
    }
    
    if (value.length < minLength) {
        throw new Error(`${fieldName} must have at least ${minLength} items`);
    }
    
    if (maxLength !== null && value.length > maxLength) {
        throw new Error(`${fieldName} must have no more than ${maxLength} items`);
    }
    
    return value;
}

/**
 * Validates email format
 */
export function isValidEmail(email) {
    if (!email || typeof email !== 'string') return false;
    
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email.trim());
}

/**
 * Validates US phone number format
 */
export function isValidPhoneNumber(phone) {
    if (!phone || typeof phone !== 'string') return false;
    
    // Remove all non-digit characters
    const cleaned = phone.replace(/\D/g, '');
    
    // Must be 10 digits (US format)
    return cleaned.length === 10;
}

/**
 * Validates ISO date string format
 */
export function isValidISOString(isoString, fieldName) {
    if (!isoString || typeof isoString !== 'string') {
        throw new Error(`${fieldName} must be a valid ISO date string`);
    }
    
    const date = new Date(isoString);
    if (isNaN(date.getTime())) {
        throw new Error(`${fieldName} must be a valid ISO date string`);
    }
    
    return date;
}

/**
 * Validates required fields are present
 */
export function validateRequiredFields(obj, requiredFields, objectName = 'Object') {
    const missing = [];
    
    for (const field of requiredFields) {
        if (obj[field] === undefined || obj[field] === null || obj[field] === '') {
            missing.push(field);
        }
    }
    
    if (missing.length > 0) {
        throw new Error(`${objectName} missing required fields: ${missing.join(', ')}`);
    }
    
    return true;
}

// =====================================================================
// DOMAIN-SPECIFIC VALIDATION FUNCTIONS
// =====================================================================

/**
 * Validates customer data according to schema
 */
export function validateCustomerData(customerData) {
    try {
        const schema = VALIDATION_SCHEMAS.customer;
        
        // Check required fields
        validateRequiredFields(customerData, schema.required, 'Customer data');
        
        // Validate individual fields
        const validated = {};
        
        // Customer name
        validated.customerName = validateString(
            customerData.customerName, 
            'Customer name', 
            2, 
            100
        );
        
        // Customer email
        validated.customerEmail = validateString(
            customerData.customerEmail,
            'Customer email',
            5,
            100
        );
        
        if (!isValidEmail(validated.customerEmail)) {
            throw new Error('Customer email must be a valid email address');
        }
        
        // Optional phone number
        if (customerData.customerPhone) {
            validated.customerPhone = validateString(
                customerData.customerPhone,
                'Customer phone',
                10,
                20
            );
            
            if (!isValidPhoneNumber(validated.customerPhone)) {
                throw new Error('Customer phone must be a valid US phone number');
            }
        }
        
        // Optional address
        if (customerData.customerAddress) {
            validated.customerAddress = validateString(
                customerData.customerAddress,
                'Customer address',
                10,
                200
            );
        }
        
        // Apply defaults
        validated.leadSource = customerData.leadSource || schema.defaults.leadSource;
        validated.leadStatus = customerData.leadStatus || schema.defaults.leadStatus;
        validated.dateCreated = customerData.dateCreated || new Date().toISOString();
        
        return {
            isValid: true,
            data: validated,
            message: SUCCESS.DATA_VALIDATED
        };
        
    } catch (error) {
        return {
            isValid: false,
            error: error.message,
            data: null
        };
    }
}

/**
 * Validates quote item data
 */
export function validateQuoteItemData(quoteItemData) {
    try {
        const schema = VALIDATION_SCHEMAS.windowMeasurement;
        
        // Check required fields
        validateRequiredFields(quoteItemData, schema.required, 'Quote item data');
        
        const validated = {};
        
        // Validate dimensions
        validated.width = validateNumber(
            quoteItemData.width,
            'Width',
            schema.ranges.width[0],
            schema.ranges.width[1]
        );
        
        validated.height = validateNumber(
            quoteItemData.height, 
            'Height',
            schema.ranges.height[0],
            schema.ranges.height[1]
        );
        
        validated.quantity = validateNumber(
            quoteItemData.quantity,
            'Quantity',
            schema.ranges.quantity[0],
            schema.ranges.quantity[1]
        );
        
        // Calculate Universal Inches
        validated.universalInches = calculateUniversalInches(
            validated.width,
            validated.height,
            validated.quantity
        );
        
        // Optional fields with defaults
        validated.windowType = quoteItemData.windowType || schema.defaults.windowType;
        validated.material = quoteItemData.material || schema.defaults.material;
        validated.brand = quoteItemData.brand || 'standard';
        
        // Validate selections exist
        if (validated.windowType && !PRICING_CONFIG.TYPES[validated.windowType]) {
            throw new Error(`Invalid window type: ${validated.windowType}`);
        }
        
        if (validated.material && !PRICING_CONFIG.MATERIALS[validated.material]) {
            throw new Error(`Invalid material: ${validated.material}`);
        }
        
        return {
            isValid: true,
            data: validated,
            message: SUCCESS.MEASUREMENTS_VALIDATED
        };
        
    } catch (error) {
        return {
            isValid: false,
            error: error.message,
            data: null
        };
    }
}

/**
 * Validates AI measurement data from image analysis
 */
export function validateAIMeasurementData(measurementData) {
    try {
        const schema = VALIDATION_SCHEMAS.aiAnalysis;
        
        // Check required fields
        validateRequiredFields(measurementData, schema.required, 'AI measurement data');
        
        const validated = {};
        
        // Session ID
        validated.sessionId = validateString(
            measurementData.sessionId,
            'Session ID',
            10,
            50
        );
        
        // Analysis results (must be object)
        if (typeof measurementData.analysisResults !== 'object' || 
            measurementData.analysisResults === null) {
            throw new Error('Analysis results must be a valid object');
        }
        validated.analysisResults = measurementData.analysisResults;
        
        // Optional confidence score
        if (measurementData.confidence !== undefined) {
            validated.confidence = validateNumber(
                measurementData.confidence,
                'Confidence',
                0,
                100
            );
        } else {
            validated.confidence = schema.defaults.confidence;
        }
        
        // Optional windows detected count
        if (measurementData.windowsDetected !== undefined) {
            validated.windowsDetected = validateNumber(
                measurementData.windowsDetected,
                'Windows detected',
                1,
                20
            );
        } else {
            validated.windowsDetected = schema.defaults.windowsDetected;
        }
        
        // Optional user contact info
        if (measurementData.userEmail) {
            validated.userEmail = validateString(measurementData.userEmail, 'User email');
            if (!isValidEmail(validated.userEmail)) {
                throw new Error('User email must be valid');
            }
        }
        
        if (measurementData.userPhone) {
            validated.userPhone = validateString(measurementData.userPhone, 'User phone');
            if (!isValidPhoneNumber(validated.userPhone)) {
                throw new Error('User phone must be valid US number');
            }
        }
        
        return {
            isValid: true,
            data: validated,
            message: SUCCESS.ANALYSIS_COMPLETE
        };
        
    } catch (error) {
        return {
            isValid: false,
            error: error.message,
            data: null
        };
    }
}

/**
 * Validates complete quote data
 */
export function validateQuoteData(quoteData) {
    try {
        const schema = VALIDATION_SCHEMAS.quote;
        
        // Check required fields
        validateRequiredFields(quoteData, schema.required, 'Quote data');
        
        const validated = {};
        
        // Customer ID
        validated.customerId = validateString(
            quoteData.customerId,
            'Customer ID',
            5,
            50
        );
        
        // Window data array
        validated.windowData = validateArray(
            quoteData.windowData,
            'Window data',
            1,
            20
        );
        
        // Validate each window item
        validated.windowData = validated.windowData.map((window, index) => {
            const windowValidation = validateQuoteItemData(window);
            if (!windowValidation.isValid) {
                throw new Error(`Window ${index + 1}: ${windowValidation.error}`);
            }
            return windowValidation.data;
        });
        
        // Total price
        validated.totalPrice = validateNumber(
            quoteData.totalPrice,
            'Total price',
            0
        );
        
        // Optional fields
        validated.notes = quoteData.notes ? 
            validateString(quoteData.notes, 'Notes', 0, 1000) : '';
        
        validated.status = quoteData.status || schema.defaults.status;
        validated.validDays = quoteData.validDays || schema.defaults.validDays;
        
        // Calculate valid until date
        const validUntil = new Date();
        validUntil.setDate(validUntil.getDate() + validated.validDays);
        validated.validUntil = validUntil.toISOString();
        
        return {
            isValid: true,
            data: validated,
            message: SUCCESS.QUOTE_GENERATED
        };
        
    } catch (error) {
        return {
            isValid: false,
            error: error.message,
            data: null
        };
    }
}

/**
 * Validates analytics event data
 */
export function validateAnalyticsEvent(eventData) {
    try {
        const required = ['eventType', 'timestamp'];
        validateRequiredFields(eventData, required, 'Analytics event');
        
        const validated = {};
        
        validated.eventType = validateString(
            eventData.eventType,
            'Event type',
            3,
            50
        );
        
        validated.timestamp = isValidISOString(eventData.timestamp, 'Timestamp');
        
        // Optional fields
        if (eventData.sessionId) {
            validated.sessionId = validateString(eventData.sessionId, 'Session ID');
        }
        
        if (eventData.userId) {
            validated.userId = validateString(eventData.userId, 'User ID');
        }
        
        if (eventData.details && typeof eventData.details === 'object') {
            validated.details = eventData.details;
        }
        
        return {
            isValid: true,
            data: validated,
            message: 'Analytics event validated'
        };
        
    } catch (error) {
        return {
            isValid: false,
            error: error.message,
            data: null
        };
    }
}

// =====================================================================
// SECURITY VALIDATION FUNCTIONS
// =====================================================================

/**
 * Validates iframe origin for security
 */
export function isValidOrigin(origin) {
    const allowedOrigins = [
        'https://goodfaithexteriors.com',
        'https://www.goodfaithexteriors.com',
        'https://goodfaithexteriors.wixsite.com',
        'https://editor.wix.com',
        'https://preview.wix.com'
    ];
    
    // Allow localhost for development
    if (origin.includes('localhost') || origin.includes('127.0.0.1')) {
        return true;
    }
    
    return allowedOrigins.includes(origin);
}

/**
 * Safe execution wrapper with error handling
 */
export function safeExecute(func) {
    return async function(...args) {
        try {
            const result = await func.apply(this, args);
            return {
                success: true,
                data: result,
                error: null
            };
        } catch (error) {
            console.error('Safe execution error:', error);
            return {
                success: false,
                data: null,
                error: error.message || 'Unknown error occurred'
            };
        }
    };
}

// =====================================================================
// UTILITY FUNCTIONS
// =====================================================================

/**
 * Calculates Universal Inches for pricing
 */
export function calculateUniversalInches(width, height, quantity = 1) {
    const w = typeof width === 'string' ? parseFloat(width) : Number(width) || 0;
    const h = typeof height === 'string' ? parseFloat(height) : Number(height) || 0;
    const q = typeof quantity === 'string' ? parseInt(quantity, 10) : Number(quantity) || 1;
    
    if (w <= 0 || h <= 0 || q <= 0) {
        throw new Error('Width, height, and quantity must be positive numbers');
    }
    
    return (w * h) * q;
}

/**
 * Generates unique session ID
 */
export function generateSessionId() {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
}

/**
 * Generates unique ID with prefix
 */
export function generateUniqueId(prefix = 'gfe') {
    return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
}

/**
 * Sanitizes data for Wix collections
 */
export function sanitizeForWix(data) {
    const sanitized = {};
    
    for (const [key, value] of Object.entries(data)) {
        if (value === null || value === undefined) {
            continue;
        }
        
        if (typeof value === 'object' && value !== null) {
            // Convert objects to JSON strings for Wix
            sanitized[key] = JSON.stringify(value);
        } else if (typeof value === 'number') {
            // Convert numbers to strings for Wix text fields
            sanitized[key] = value.toString();
        } else {
            sanitized[key] = value;
        }
    }
    
    return sanitized;
}

/**
 * Creates success response
 */
export function createSuccessResponse(data, message = 'Operation successful') {
    return {
        success: true,
        data,
        message,
        timestamp: new Date().toISOString()
    };
}

/**
 * Creates error response
 */
export function createErrorResponse(error, context = '') {
    return {
        success: false,
        error: error.message || error,
        context,
        timestamp: new Date().toISOString()
    };
}

/**
 * Maps field names using FIELD_MAPPINGS
 */
export function mapFields(data, mappingKey) {
    const mapping = FIELD_MAPPINGS[mappingKey];
    if (!mapping) {
        return data;
    }
    
    const mapped = {};
    for (const [key, value] of Object.entries(data)) {
        const mappedKey = mapping[key] || key;
        mapped[mappedKey] = value;
    }
    
    return mapped;
}

/**
 * Gets collection name from COLLECTIONS constant
 */
export function getCollectionName(collectionKey) {
    return COLLECTIONS[collectionKey] || collectionKey;
}

// =====================================================================
// EXPORTS
// =====================================================================

export default {
    // Validation functions
    validateString,
    validateNumber, 
    validateBoolean,
    validateArray,
    isValidEmail,
    isValidPhoneNumber,
    isValidISOString,
    validateRequiredFields,
    
    // Domain-specific validation
    validateCustomerData,
    validateQuoteItemData,
    validateAIMeasurementData,
    validateQuoteData,
    validateAnalyticsEvent,
    
    // Security functions
    isValidOrigin,
    safeExecute,
    
    // Utility functions
    calculateUniversalInches,
    generateSessionId,
    generateUniqueId,
    sanitizeForWix,
    createSuccessResponse,
    createErrorResponse,
    mapFields,
    getCollectionName
};