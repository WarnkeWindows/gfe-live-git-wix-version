// unified-gfe-api-client.js
// Good Faith Exteriors - Unified API Client for All Home Remodeling Services
// Handles all communication between frontend and backend services

// ============================================================================
// API CLIENT CONFIGURATION
// ============================================================================

const API_CONFIG = {
  // Backend URLs
  baseUrl: 'https://good-faith-exteriors.uc.r.appspot.com',
  
  // API endpoints for unified services
  endpoints: {
    // Core AI analysis endpoints
    analyzeExterior: '/analyze-exterior-component',
    validateMeasurements: '/validate-measurements-unified',
    generateQuote: '/generate-unified-quote',
    generateProjectScope: '/generate-project-scope',
    
    // Customer management
    createCustomer: '/customer',
    getCustomer: '/customer',
    
    // Communication
    sendQuoteEmail: '/sendQuoteEmail',
    sendProjectScopeEmail: '/sendProjectScopeEmail',
    scheduleConsultation: '/scheduleConsultation',
    
    // Product data
    getProducts: '/products-unified',
    getMaterials: '/materials-unified',
    getBrands: '/brands-unified',
    
    // System health
    systemHealth: '/system-health'
  },

  // Request configuration
  defaultTimeout: 30000,
  maxRetries: 3,
  retryDelay: 1000,
  
  // Supported services
  supportedServices: [
    'windows', 'doors', 'roofing', 'siding', 'gutters', 'storm_damage'
  ],

  // File upload limits
  maxFileSize: 10 * 1024 * 1024, // 10MB
  allowedImageTypes: ['image/jpeg', 'image/png', 'image/webp'],

  // Error codes
  errorCodes: {
    NETWORK_ERROR: 'NETWORK_ERROR',
    TIMEOUT_ERROR: 'TIMEOUT_ERROR',
    VALIDATION_ERROR: 'VALIDATION_ERROR',
    API_ERROR: 'API_ERROR',
    AUTH_ERROR: 'AUTH_ERROR'
  }
};

// ============================================================================
// UNIFIED API CLIENT CLASS
// ============================================================================

class UnifiedGFEApiClient {
  constructor() {
    this.baseUrl = API_CONFIG.baseUrl;
    this.sessionId = this.generateSessionId();
    this.requestId = 0;
    this.activeRequests = new Map();
  }

  // ============================================================================
  // CORE REQUEST METHODS
  // ============================================================================

  async makeRequest(endpoint, options = {}) {
    const requestId = ++this.requestId;
    const timeoutId = setTimeout(() => {
      this.activeRequests.delete(requestId);
    }, options.timeout || API_CONFIG.defaultTimeout);

    try {
      this.activeRequests.set(requestId, { timeoutId, endpoint });

      const url = `${this.baseUrl}${endpoint}`;
      const requestOptions = {
        method: options.method || 'GET',
        headers: {
          'Content-Type': 'application/json',
          'X-Session-ID': this.sessionId,
          'X-Request-ID': requestId,
          ...options.headers
        },
        ...options
      };

      if (options.body && typeof options.body === 'object') {
        requestOptions.body = JSON.stringify(options.body);
      }

      console.log(`[API] ${requestOptions.method} ${url}`, options.body || '');

      const response = await fetch(url, requestOptions);
      const data = await response.json();

      clearTimeout(timeoutId);
      this.activeRequests.delete(requestId);

      if (!response.ok) {
        throw this.createApiError(response.status, data.error || 'Request failed', data);
      }

      console.log(`[API] Response:`, data);
      return data;

    } catch (error) {
      clearTimeout(timeoutId);
      this.activeRequests.delete(requestId);

      if (error.name === 'AbortError') {
        throw this.createError(API_CONFIG.errorCodes.TIMEOUT_ERROR, 'Request timeout');
      }

      console.error(`[API] Error in ${endpoint}:`, error);
      throw error;
    }
  }

  async makeRequestWithRetry(endpoint, options = {}) {
    let lastError;
    
    for (let attempt = 1; attempt <= API_CONFIG.maxRetries; attempt++) {
      try {
        return await this.makeRequest(endpoint, options);
      } catch (error) {
        lastError = error;
        
        if (attempt === API_CONFIG.maxRetries || !this.isRetryableError(error)) {
          break;
        }

        const delay = API_CONFIG.retryDelay * Math.pow(2, attempt - 1);
        console.log(`[API] Retry ${attempt}/${API_CONFIG.maxRetries} after ${delay}ms for ${endpoint}`);
        await this.delay(delay);
      }
    }

    throw lastError;
  }

  // ============================================================================
  // EXTERIOR COMPONENT ANALYSIS
  // ============================================================================

  async analyzeExteriorComponent(analysisData) {
    try {
      this.validateAnalysisData(analysisData);

      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.analyzeExterior,
        {
          method: 'POST',
          body: {
            imageData: analysisData.imageData,
            componentType: analysisData.componentType,
            analysisType: analysisData.analysisType || 'comprehensive',
            customerInfo: analysisData.customerInfo,
            projectContext: analysisData.projectContext || {},
            propertyDetails: analysisData.propertyDetails || {},
            sessionId: this.sessionId
          },
          timeout: 45000 // Longer timeout for AI analysis
        }
      );

      return this.processAnalysisResponse(response);

    } catch (error) {
      throw this.enhanceError(error, 'Failed to analyze exterior component');
    }
  }

  async validateMeasurements(validationData) {
    try {
      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.validateMeasurements,
        {
          method: 'POST',
          body: {
            userMeasurements: validationData.userMeasurements,
            aiAnalysis: validationData.aiAnalysis,
            componentType: validationData.componentType,
            sessionId: this.sessionId
          }
        }
      );

      return this.processValidationResponse(response);

    } catch (error) {
      throw this.enhanceError(error, 'Failed to validate measurements');
    }
  }

  // ============================================================================
  // QUOTE GENERATION
  // ============================================================================

  async generateUnifiedQuote(quoteData) {
    try {
      this.validateQuoteData(quoteData);

      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.generateQuote,
        {
          method: 'POST',
          body: {
            quoteItems: quoteData.quoteItems,
            customerInfo: quoteData.customerInfo,
            customerPreferences: quoteData.customerPreferences || {},
            includeLaborCosts: quoteData.includeLaborCosts !== false,
            includeFinancing: quoteData.includeFinancing !== false,
            sessionId: this.sessionId
          },
          timeout: 35000
        }
      );

      return this.processQuoteResponse(response);

    } catch (error) {
      throw this.enhanceError(error, 'Failed to generate quote');
    }
  }

  async generateProjectScope(projectData) {
    try {
      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.generateProjectScope,
        {
          method: 'POST',
          body: {
            projectComponents: projectData.projectComponents,
            customerPreferences: projectData.customerPreferences || {},
            propertyConstraints: projectData.propertyConstraints || {},
            timeline: projectData.timeline,
            budget: projectData.budget,
            sessionId: this.sessionId
          },
          timeout: 40000
        }
      );

      return this.processProjectScopeResponse(response);

    } catch (error) {
      throw this.enhanceError(error, 'Failed to generate project scope');
    }
  }

  // ============================================================================
  // CUSTOMER MANAGEMENT
  // ============================================================================

  async createOrUpdateCustomer(customerData) {
    try {
      this.validateCustomerData(customerData);

      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.createCustomer,
        {
          method: 'POST',
          body: {
            customerData: customerData,
            sessionId: this.sessionId
          }
        }
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to save customer information');
    }
  }

  async getCustomer(email) {
    try {
      const response = await this.makeRequestWithRetry(
        `${API_CONFIG.endpoints.getCustomer}?email=${encodeURIComponent(email)}`
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to retrieve customer information');
    }
  }

  // ============================================================================
  // COMMUNICATION SERVICES
  // ============================================================================

  async sendQuoteEmail(emailData) {
    try {
      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.sendQuoteEmail,
        {
          method: 'POST',
          body: {
            customerEmail: emailData.customerEmail,
            customerName: emailData.customerName,
            quoteData: emailData.quoteData,
            explanationText: emailData.explanationText,
            sessionId: this.sessionId
          }
        }
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to send quote email');
    }
  }

  async sendProjectScopeEmail(emailData) {
    try {
      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.sendProjectScopeEmail,
        {
          method: 'POST',
          body: {
            customerEmail: emailData.customerEmail,
            customerName: emailData.customerName,
            projectScopeData: emailData.projectScopeData,
            sessionId: this.sessionId
          }
        }
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to send project scope email');
    }
  }

  async scheduleConsultation(consultationData) {
    try {
      const response = await this.makeRequestWithRetry(
        API_CONFIG.endpoints.scheduleConsultation,
        {
          method: 'POST',
          body: {
            customerInfo: consultationData.customerInfo,
            preferredTimes: consultationData.preferredTimes,
            serviceType: consultationData.serviceType,
            urgency: consultationData.urgency || 'normal',
            notes: consultationData.notes,
            sessionId: this.sessionId
          }
        }
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to schedule consultation');
    }
  }

  // ============================================================================
  // PRODUCT DATA
  // ============================================================================

  async getProducts(filters = {}) {
    try {
      const queryParams = new URLSearchParams({
        serviceType: filters.serviceType || '',
        category: filters.category || '',
        material: filters.material || '',
        brand: filters.brand || '',
        isActive: filters.isActive !== false
      });

      const response = await this.makeRequestWithRetry(
        `${API_CONFIG.endpoints.getProducts}?${queryParams}`
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to fetch products');
    }
  }

  async getMaterials(serviceType = '') {
    try {
      const queryParams = serviceType ? `?serviceType=${serviceType}` : '';
      const response = await this.makeRequestWithRetry(
        `${API_CONFIG.endpoints.getMaterials}${queryParams}`
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to fetch materials');
    }
  }

  async getBrands(serviceType = '') {
    try {
      const queryParams = serviceType ? `?serviceType=${serviceType}` : '';
      const response = await this.makeRequestWithRetry(
        `${API_CONFIG.endpoints.getBrands}${queryParams}`
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to fetch brands');
    }
  }

  // ============================================================================
  // SYSTEM MONITORING
  // ============================================================================

  async checkSystemHealth() {
    try {
      const response = await this.makeRequest(
        API_CONFIG.endpoints.systemHealth,
        { timeout: 10000 }
      );

      return response;

    } catch (error) {
      throw this.enhanceError(error, 'Failed to check system health');
    }
  }

  // ============================================================================
  // UTILITY METHODS
  // ============================================================================

  async fileToBase64(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => {
        const base64 = reader.result.split(',')[1];
        resolve(base64);
      };
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  generateSessionId() {
    return `gfe_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  formatCurrency(amount) {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD'
    }).format(amount);
  }

  formatDate(date) {
    return new Intl.DateTimeFormat('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    }).format(new Date(date));
  }

  getUserFriendlyErrorMessage(error) {
    if (error.code === API_CONFIG.errorCodes.NETWORK_ERROR) {
      return 'Network connection error. Please check your internet connection and try again.';
    }
    
    if (error.code === API_CONFIG.errorCodes.TIMEOUT_ERROR) {
      return 'Request timeout. The server is taking longer than expected to respond.';
    }
    
    if (error.code === API_CONFIG.errorCodes.VALIDATION_ERROR) {
      return error.message || 'Please check your input and try again.';
    }
    
    if (error.code === API_CONFIG.errorCodes.AUTH_ERROR) {
      return 'Authentication error. Please refresh the page and try again.';
    }

    return error.message || 'An unexpected error occurred. Please try again.';
  }

  // ============================================================================
  // ANALYTICS AND LOGGING
  // ============================================================================

  logAnalyticsEvent(eventName, properties = {}) {
    try {
      const analyticsData = {
        event: eventName,
        properties: {
          ...properties,
          sessionId: this.sessionId,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href
        }
      };

      // Send to analytics endpoint (fire and forget)
      this.makeRequest('/analytics', {
        method: 'POST',
        body: analyticsData
      }).catch(error => {
        console.warn('Analytics logging failed:', error);
      });

    } catch (error) {
      console.warn('Failed to log analytics event:', error);
    }
  }

  // ============================================================================
  // VALIDATION METHODS
  // ============================================================================

  validateAnalysisData(data) {
    if (!data.imageData) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Image data is required');
    }

    if (!data.componentType || !API_CONFIG.supportedServices.includes(data.componentType)) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Valid component type is required');
    }

    if (!data.customerInfo || !data.customerInfo.email) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Customer email is required');
    }
  }

  validateQuoteData(data) {
    if (!data.quoteItems || !Array.isArray(data.quoteItems) || data.quoteItems.length === 0) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'At least one quote item is required');
    }

    if (!data.customerInfo || !data.customerInfo.email) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Customer information is required');
    }

    data.quoteItems.forEach((item, index) => {
      if (!item.service || !item.quantity) {
        throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, `Quote item ${index + 1} is missing required fields`);
      }
    });
  }

  validateCustomerData(data) {
    if (!data.email) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Email is required');
    }

    if (!this.isValidEmail(data.email)) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Valid email address is required');
    }

    if (!data.fullName || data.fullName.length < 2) {
      throw this.createError(API_CONFIG.errorCodes.VALIDATION_ERROR, 'Full name is required');
    }
  }

  isValidEmail(email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
  }

  // ============================================================================
  // RESPONSE PROCESSING
  // ============================================================================

  processAnalysisResponse(response) {
    if (!response.success) {
      throw this.createError(API_CONFIG.errorCodes.API_ERROR, response.error);
    }

    return {
      success: true,
      data: {
        analysis: response.data.analysis || {},
        confidence: response.data.confidence || 0,
        recommendations: response.data.recommendations || [],
        detectedMeasurements: response.data.detectedMeasurements,
        condition: response.data.condition,
        material: response.data.material,
        estimatedCost: response.data.estimatedCost
      }
    };
  }

  processValidationResponse(response) {
    if (!response.success) {
      throw this.createError(API_CONFIG.errorCodes.API_ERROR, response.error);
    }

    return {
      success: true,
      data: {
        isValid: response.data.isValid,
        confidence: response.data.confidence || 0,
        concerns: response.data.concerns || [],
        recommendations: response.data.recommendations || [],
        adjustedMeasurements: response.data.adjustedMeasurements
      }
    };
  }

  processQuoteResponse(response) {
    if (!response.success) {
      throw this.createError(API_CONFIG.errorCodes.API_ERROR, response.error);
    }

    return {
      success: true,
      data: {
        quote: response.data.quote,
        explanation: response.data.explanation,
        financing: response.data.financing,
        validUntil: response.data.validUntil
      }
    };
  }

  processProjectScopeResponse(response) {
    if (!response.success) {
      throw this.createError(API_CONFIG.errorCodes.API_ERROR, response.error);
    }

    return {
      success: true,
      data: {
        projectScope: response.data.projectScope,
        timeline: response.data.timeline,
        phases: response.data.phases || [],
        estimatedCost: response.data.estimatedCost,
        recommendations: response.data.recommendations || []
      }
    };
  }

  // ============================================================================
  // ERROR HANDLING
  // ============================================================================

  createError(code, message, details = {}) {
    const error = new Error(message);
    error.code = code;
    error.details = details;
    error.timestamp = new Date().toISOString();
    return error;
  }

  createApiError(status, message, data) {
    let code;
    if (status >= 400 && status < 500) {
      code = status === 401 ? API_CONFIG.errorCodes.AUTH_ERROR : API_CONFIG.errorCodes.VALIDATION_ERROR;
    } else {
      code = API_CONFIG.errorCodes.API_ERROR;
    }

    return this.createError(code, message, { status, data });
  }

  enhanceError(error, contextMessage) {
    if (error.code) {
      return error; // Already enhanced
    }

    return this.createError(
      API_CONFIG.errorCodes.API_ERROR,
      `${contextMessage}: ${error.message}`,
      { originalError: error }
    );
  }

  isRetryableError(error) {
    if (error.code === API_CONFIG.errorCodes.NETWORK_ERROR) return true;
    if (error.code === API_CONFIG.errorCodes.TIMEOUT_ERROR) return true;
    if (error.details && error.details.status >= 500) return true;
    return false;
  }

  delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// ============================================================================
// INITIALIZE AND EXPORT
// ============================================================================

// Create client instance
const unifiedApiClient = new UnifiedGFEApiClient();

// Export for use in modules and global scope
export { unifiedApiClient as default, UnifiedGFEApiClient, API_CONFIG };